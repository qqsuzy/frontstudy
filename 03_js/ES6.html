<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <script>

    // ES6 ECMA2015를 의미한다.

    /* 
      선언 키워드

      1. let
        1) 블록 레벨 { }의 스코프를 가진다.
        2) 초기화를 생략할 수 있다. 
        3) 재선언이 불가능하다.
        4) 지역 변수 용도로 사용한다.
        
      2. const
        1) 블록 레벨 { }의 스코프를 가진다.
        2) 반드시 초기화가 필요하다.
        3) 재선언이 불가능하다.
        4) 상수 용도로 사용한다.
    */

    // let
    var array = [10, 1.5, 'A'];
    for(let i = 0; i < array.length; i++) {  // let -> 지역변수로 { } 스코프 안에서만 사용 가능하다.
      console.log(array[i]);
    }
    console.log(i);  // let 변수를 사용해서 스코프 밖에서는 i 사용이 불가능하다. (지역변수)

    // const
    const func = function() {  // const는 함수 저장용으로 사용 권장한다.
      console.log('func 실행');
    }
    func();

  </script>

  <script>
  
    /* 
      back tick(`) 지원
      1. Multiple-line 문자열 지원 - back tick 으로 묶어주면 입력한 그대로(space, enter ...) 출력해준다.
      2. 템플릿 리터럴 (template literals) 지원
    */

    let str = `안녕하세요
반갑습니다`;
    console.log(str);

    const name = '고길동';
    console.log('내 이름은 ' + name + '입니다.');
    console.log(`내 이름은 ${name}입니다.`);  // 템플릿 리터럴 : $ 로 변수값 넣어줄 수 있다. ${ } 가 코드 내에 있으면 변수가 있음을 명확히 알 수 있다.
    
  </script>

  <script>
    
    /* 
      구조 분해
      1. 객체는 '속성:값' 으로 데이터를 구성한다.
      2. 객체를 구성하는 각 속성의 값을 일반 변수로 쉽게 가져올 수 있다.
      3. 배열의 요소도 일반 변수로 하나씩 쉽게 가져올 수 있다.

      ▶ 구조분해는 배열보다는 주로 객체를 주고 받을 때 많이 사용된다.
    */

    // 객체 구조 분해
    const car = {
      maker: 'bmw',
      model: '5시리즈'
    };

    // 구조 분해 할당
    var { maker, model } = car;

    console.log(maker, model);

    // 배열 구조 분해
    const colors = ['red', 'green', 'blue'];
    /*
    var a = color[0];
    var b = color[1];
    var c = color[2];
    */

   // 구조 분해 할당
    var [a, b, c] = colors;
    console.log(a, b, c);

  </script>

  <script>

    /*
      화살표 함수 (arrow funcions)
      1. 익명 함수의 다른 표현 방식이다.
      2. 형식
        1) 화살표 함수를 이용한 함수 표현식  (function을 지우고 화살표(=>)를 추가한다.)
          const 함수이름 = ([매개변수]) => {         

          }
        2) 함수 호출
          함수이름([인자]);
    */
   
    const myFunc1 = () => {
      console.log('myFunc 실행');
    }
    
    myFunc1();


    // 화살표 함수 사용 시 return 만 존재하는 경우 (위에 코드와 비교하기)
    // 1. { } 중괄호 생략 가능하다.
    // 2. return 키워드 생략 가능하다.
    const myFunc2 = () => 'hello world';    

    console.log(myFunc2());

  </script>

  <script>

    /* 
      말 줄임표(..., 전개 연산자) 지원
      1. 전달되는 인자 개수가 일정하지 않을 때 사용한다.
      2. 배열로 처리한다.
    */

    // 4. 말 줄임표(..., 전개 연산자) 
    const getTotal = (...numbers) => {  // nubmers는 배열로 처리한다.
      var total = 0;
      for(var i = 0; i < numbers.length; i++) {
        total += numbers[i];
      }
       return total;
    }

    console.log((1, 2, 3));
    console.log((1, 2, 3, 4));

  </script>

  <script>

    /* 비동기 작업 : 응답을 기다리지 않는다. */

    let albumId; // 초기화가 없으면 undefined 상태
    const xhr = new XMLHttpRequest();

    xhr.open('GET', 'https://jsonplaceholder.typicode.com/photos/1');
    xhr.send();

    xhr.addEventListener('readystatechange', () => {
      if(xhr.readyState !== XMLHttpRequest.DONE)
        return;
      if(xhr.status !== 200)
        return;
      let album = JSON.parse(xhr.responseText); 
      albumId = album.albumId;
    });
    console.log('albumId:',albumId); // albumId는 1이기를 기대하지만, 비동기 작업의 응답을 기다리지 않고 곧바로 실행되기 때문에 undefined 상태가 된다.
    // 비동기 작업의 경우 코드 순서대로 작동하기를 기대하면 안된다.
    // albumId 변수 선언 후 데이터를 받아오기까지 응답을 기다리지 않고 바로 console에 출력을 해서 undefined 상태로 나온다. 
    // 여러개의 비동기 작업을 할 경우에 요청한 순서대로 작업되지 않고, 먼저 처리된 것을 보여주며 처리되지 않는 것은 나중에 보여준다. 

  </script>

  <script>
    /*
      Promise
      1. 비동기 작업이 맞이할 미래의 완료 또는 실패에 따른 그 결과값을 나타내는 객체이다.
      2. 미래의 어떤 시점에 결과를 제공하겠다는 '약속'을 반환하는 방식으로 동작한다.
      3. Promise 상태
        1) pending    : 초기상태 (이행도 아니고 거부도 아닌 상태)
        2) fulfilled  : 이행상태 (비동기 작업 성공)
        3) reject     : 거부상태 (비동기 작업 실패)
      4. Promise 생성자
        1) Promise를 지원하지 않는 함수를 Promise로 만들 때 사용한다.
        2) 형식
          new Promise(executor)
        3) executor : 실행 함수
          (1) 인자가 resolve, reject인 실행 함수이다.
          (2) resolve는 Promise 이행 함수(fufilled 상태)이고, reject은 Promise 거부 함수(reject 상태)이다.
      5. Promise의 then() 메소드
        1) Promise 객체가 호출할 수 있다.
        2) Promise 이행 함수와 Promise 거부 함수를 콜백으로 추가한다. (함수(메소드?) -> 함수 전달)
        3) 콜백이 호출될 경우 그 반환값을 처리하고, 호출되지 않는 경우 처리된 상태와 값을 그대로 가진 새로운 Promise를 반환한다.
        4) 형식
          then(()=>{// 이행 함수}, [()=>{// 거부 함수}])  -- 함수 안에 함수가 2개 전달, 이행 함수만 처리를 원하면 거부 함수는 생략이 가능하다.

          -> 이행과 거부 순서대로 작성한다.

        < promise를 함수 형식으로 표현하는 방법 >
          const func = () => {
            return new Promise();
          }
          func()
          .then();
    */

    let albumId2;
    const myPromise = new Promise((resolve,reject)=>{
      const xhr = new XMLHttpRequest();
      xhr.open('GET', 'https://jsonplaceholder.typicode.com/photos/1');
      xhr.send();
      xhr.addEventListener('readystatechange', ()=>{
        if(xhr.readyState !== XMLHttpRequest.DONE)
          return;
        if(xhr.status !== 200){                // 응답 실패 = 거부상태 
          reject(xhr.statusText);              // Promise 거부 함수 실행 (Parameter에 거부 사유를 전달 가능하다. 일반 문자열을 작성도 가능하다.)
        resolve(JSON.parse(xhr.responseText)); // promise 이행 함수 실행 (Parameter에 응답 결과를 전달 가능하다.) 
        // 여기까지의 실행 결과가 myPromise에 저장된다. 
        }
      })
    });
    myPromise
      .then((resData)=>{ // 비동기 통신 응답을 성공했을 때, 결과를 then 메소드의 첫번째 parameter에 전달한다.
        console.log(resData);
        albumId2 = resData.albumId;
        console.log('albumId2:', albumId2);
      }, (msg)=>{  // 거부 상태(reject)에서 실행되는 함수
        console.log(msg);
      });
    
  </script>

  <script>

    const fnPromise1 = (url) => {
      return new Promise((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();
        // load 이벤트 : XMLHttpRequest 트랜잭션 성공 시 발생하는 이벤트
        xhr.addEventListener('load', () => {
          resolve(JSON.parse(xhr.responseText));
        })
        // error 이벤트 : 실패 시 발생하는 이벤트
        xhr.addEventListener('error', ()=>{
          reject(xhr.statusText);
        })
      }); 
    }

    fnPromise1('https://jsonplaceholder.typicode.com/photos/1')
      .then((resData) => {
        console.log(resData);
      }, (msg)=>{
        console.log(msg);
      });

  </script>

  <script>
    const fnPromise2 = (method, url)=>{
      return new Promise ((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.send();
        xhr.addEventListener('load', ()=>resolve(xhr.responseXML)); // 하나의 retrun 만 존재하여 { } 중괄호 생략 가능하다. 
        xhr.addEventListener('error', ()=>reject(xhr.statusText));
      });
    }

    fnPromise2('GET', 'https://thetestrequest.com/authors/1.xml')
      .then((resData)=>{
        console.log(resData); // XMLDocument 출력
      }, (msg)=>{
        console.log(msg);
      });

  </script>

  <script>
    /*
      fetch() 전역 함수
      1. 네트워크에서 자원 (리소스) 취득을 시작한 뒤 응답이 가능한 상태가 되면 이를 이행하는 Promise를 반환한다.
      2. Response 객체를 이행 함수에 전달한다. (이행한다.)
      3. Response 객체 가진 데이터를 반환하는 메소드
        1) json() : JSON 데이터를 이행하는 Promise 반환
        2) text() : 텍스트 데이터를 이행하는 Promise 반환
        3) blob() : 바이너리(블롭) 데이터를 이행하는 Promise 반환
      4. 형식
        fetch(resource, [options])
        1) resource : 일반적으로 URL 또는 Request 객체
        2) options
          (1) method  : 요청 메소드 (GET, POST, PUT, DELETE 등)
          (2) headers : 요청 헤더 (GET)
          (3) body    : 요청 본문 (POST) , 주로 blob / FormData 등
          (4) mode    : 요청 모드 (cors, no-cors, same-origin)
          (5) cache   : HTTP 캐시 (no-cache, force-cache 등) -> 개발 중에는 no-cache 권장! (코드가 바뀌면 새로 요청하고 코드가 바뀌지 않으면 기존 캐시 사용?)
              
              캐시란? 
              자주 사용하는 데이터를 임시로 복사해두는 임의의 장소 (캐싱: 데이터를 캐시에 저장하는 행위)
              
              - 캐싱은 캐시에 저장된 데이터에 접근하는 시간에 비해 원본 데이터에 접근하는 시간이 오래 걸리는 경우 사용한다.
              - 데이터 접근을 위해 네트워크를 사용해야하는 웹 환경에서도 캐시는 유용하게 사용된다.
              - HTTP 캐싱을 활용하면 웹 사이트의 로딩 시간을 개선할 수 있다. 
              - 이미지 또는 JS, CSS와 같은 파일들은 자주 변하지 않는데, 캐시를 사용하지 않으면 
                자주 변하지 않는 데이터라도 요청할 때 마다 새롭게 다운로드 해야한다. (비용 발생, 서버에 부담을 줌)
              
    */

    // options
      const options = {
        method : 'GET'
      }
    // JSON
    fetch ('https://jsonplaceholder.typicode.com/photos/1', options)
     .then((response)=>{ // error 로 처리하지 않는 경우 : fetch는 응답이 오면 error로 처리하지 않는다. (ex 404의 경우도 성공으로 본다.)
      // 실제 응답 성공 여부를 처리하기를 권장 (검사)
      if(response.ok) {         // response 의 속성 (property) ok 
        return response.json(); // 성공을 했다면, JSON 데이터를 가지고 있지 않고 return 한다.
      }
     })
     .then((resData)=>{        
        console.log(resData);   // promise 데이터를 받아와서 결과를 뿌려준다.
     })
     
     /*
     위와 같은 코드 (생략 ver.)
     .then(response=>response.json())
     .then(resData=>console.log(resData))
     */

     // XML
     fetch('https://thetestrequest.com/authors/1.xml', options)
      .then((response) =>{
        if(response.ok)
          return response.text();
      })
      .then((resData)=>{
        // parseFromString(string, mime-type)
        // mime-type 
        // 1) text/plain       : 일반 텍스트 데이터
        // 2) text/html        : HTML 데이터 
        // 3) application/xml  : XML 데이터
        // 4) application/json : JSON 데이터

        // console.log(resData);      // DOMParser : string 을 document 로 바꾸어준다. (string 으로 받아오면 parsing이 어렵다.) 
        let domParse = new DOMParser  // XML or HTML source code from a string into a DOM Document.
        let xmlDoc = domParse.parseFromString(resData, 'application/xml');
        console.log(xmlDoc);
      })


      
      
  </script>

  <div id="div1">
    <img>
  </div>
  <script>
    // blob(대표적으로 이미지)

    fetch('../../assets/image/animal1.jpg')
      .then((response)=>{
        if(!response.ok)
          throw new Error(response.status);
        return response.blob();
      })
      .then((binaryImage)=>{ 
        let img = document.querySelector('#div1 > img');
        img.src = URL.createObjectURL(binaryImage);
        img.width = 192;
      })
      .catch((msg)=>{
        console.log(msg);
      })
  </script>
  
  <hr>

  <div id="div2">
    <button type="button">사용자조회</button>
    <div></div>
  </div>
  <script>
    
    // 사용자 목록 : https://jsonplaceholder.typicode.com/users
    
    // div2 > div 에 id, name, username, email, address, phone, website, company 가져오기

    const getUsers = (param1, param2)=>{
      fetch(param1, { method: param2})
        .then(response=>response.json())
        .then(resData=>{
            let result = '';
            for(let i = 0; i < resData.length; i++){
            result += '<ul>';
            result += `<li>id: ${resData[i].id}</li>`;
            result += `<li>name: ${resData[i].name}</li>`;
            result += `<li>username: ${resData[i].username}</li>`;
            result += `<li>email: ${resData[i].username}</li>`;
            result += `<li>address.street: ${resData[i].address.street}</li>`;
            result += `<li>address.suite: ${resData[i].address.suite}</li>`;
            result += `<li>address.city: ${resData[i].address.city}</li>`;
            result += `<li>address.zipcode: ${resData[i].address.zipcode}</li>`;
            result += `<li>address.geo.lat: ${resData[i].address.geo.lat}</li>`;
            result += `<li>address.geo.lng: ${resData[i].address.geo.lng}</li>`;
            result += `<li>phone: ${resData[i].phone}</li>`;
            result += `<li>website: ${resData[i].website}</li>`;
            result += `<li>company.name: ${resData[i].company.name}</li>`;
            result += `<li>company.catchPhrase: ${resData[i].company.catchPhrase}</li>`;
            result += `<li>company.bs: ${resData[i].company.bs}</li>`;
            result += '</ul>';
          }
            document.querySelector('#div2 > div').innerHTML = result;
        });
      }

        document.querySelector('#div2 > button')
        .addEventListener(
        'click', 
        ()=>{
        getUsers('https://jsonplaceholder.typicode.com/users', 'GET');
      }
    );


    //   return myPromise2 = new Promise ((resolve,reject)=>{
    //     const xhr = new XMLHttpRequest();
    //     xhr.open(method, url);
    //     xhr.send();

    //     xhr.addEventListener('load', ()=>resolve(resData = JSON.parse(xhr.responseText)));
    //     xhr.addEventListener('error', ()=>reject(xhr.statusText));
    //     let result = '';

    //     const userData = [];
    //     userData = {id}
        
    //       result += '<div>';
    //       result += '<div>id:' + resData.id + '</div>';
    //       result += '<div>name:' + resData.name + '</div>';
    //       result += '<div>username:' + resData.username + '</div>';
    //       result += '<div>email:' + resData.email + '</div>';
    //       result += '<div>address_street:' + resData.address.street + '</div>';
    //       result += '<div>address_suit:' + resData.address.suit + '</div>';
    //       result += '<div>address_city:' + resData.address.city + '</div>';
    //       result += '<div>address_zipcode:' + resData.address.zipcode + '</div>';
    //       result += '<div>phone:' + resData.phone + '</div>';
    //       result += '<div>website:' + resData.website + '</div>';
    //       result += '<div>company:' + resData.company + '</div>';
    //       result += '</div>';

    //   })
    // }

    // document.querySelector('#div2 > button').addEventListener(
    //     'click', 
    //     ()=>{
    //     getUsers('https://jsonplaceholder.typicode.com/users', 'GET');
    //   }
    // );

  </script>

  <div id="div3">
    <button type="button" id="btn7">저자요청</button>
    <div id="content1"></div>
  </div>

  <style>
  </style>

  <script>

    const getAuthors = (param1, param2) => {
      fetch(param1, {method:param2})
        .then(response=>response.text())
        .then(resData=>{
          let domParse = new DOMParser;
          let xmlDoc = domParse.parseFromString(resData, 'application/xml');
          let objects = xmlDoc.getElementsByTagName('object');
          let result = '';
          for(i = 0; i < objects.length; i++) {
            result += `<div>`;
            result += `<div>id: ${objects[i].getElementsByTagName('id')[0].textContent}</div>`;
            result += `<div>name: ${objects[i].getElementsByTagName('name')[0].textContent}</div>`;
            result += `<div>email: ${objects[i].getElementsByTagName('email')[0].textContent}</div>`;
            result += `<div>created-at: ${objects[i].getElementsByTagName('created-at')[0].textContent}</div>`;
            result += `<div>updated-at: ${objects[i].getElementsByTagName('updated-at')[0].textContent}</div>`;
            result += `<div><img src="${objects[i].getElementsByTagName('avatar')[0].textContent}"></div>`;
            result += `</div>`;
          }
          document.getElementById('content1').innerHTML = result;
        })
    }

    document.getElementById('btn7').addEventListener('click', ()=>{
      getAuthors ('https://thetestrequest.com/authors.xml', 'GET')
    });



  </script>
  



  <script>
    /* ES8(ECMA2017)에서 도입된 async와 await 키워드 */

    /*
      async 키워드
      1. 비동기 함수를 만드는 키워드이다. 
      2. 함수 앞에 추가된다.
        1) async function 함수이름() {}
        2) acync function () {}
        3) acync ()=>{}
        4) const 함수이름 = async function() {}
        4) const 함수이름 = async ()=>{}
      3. async 함수는 항상 Promise를 반환한다.
    */

    /*
      await 키워드
      1. Promise 이행을 기다리기 위해서 사용한다.
      2. 오직 async 함수 내부에서만 사용할 수 있다.
      3. 형식
        value = await expression  // Promise 비동기 작업을 기다렸다가 값이 넘어오면 처리한다.
    */
  </script>
  <script>
    function fnHold(number, second) {
      return new Promise((resolve, reject)=>{
       setTimeout(()=>resolve(number), second * 1000); 
      });
    }

    async function fnAdder (number1, number2){ // Promise 비동기 함수로?
      let n1 = await fnHold(number1, 3);       // then으로 작업할게 아니면 async로 잡는다
      let n2 = await fnHold(number2, 2);
      console.log(n1 + n2);
    }
    fnAdder(10, 20);

  </script>

  <script>

    async function aaa() { // async 키워드로 함수를 생성하면 Promise를 반환한다.
      return 'aaa';
    }

    async function bbb() {
      let a = await aaa(); // aaa() 함수의 반환 Promise가 이행(resolve)될 때까지 기다린다. aaa() 함수를 호출하여 'aaa'를 변수 a에 저장한다.
      console.log('bbb', a);
    }

    bbb();

    // aaa()
    //   .then(value=>console.log(value));

  </script>

  <script>

    async function getAlbum() {
     const response = await fetch('https://jsonplaceholder.typicode.com/photos/1', {method: 'GET'});
     if(response.ok) {
       return await response.json(); // json()의 반환값 : JSON을 가지고 있는 Promise -> JSON을 미래에 넘길 것이라고 약속!
     } else {                        // then이 사라지고
      return Promise.reject(response.statusText) // 직접 만드는 방식
     }                               
    }

    getAlbum()
      .then(resData=>console.log(resData))  // 드디어 then으로 JSON 데이터가 넘어와서 resData로 받고 console에 찍어준다.
      .catch(msg=>console.log(msg));        // reject 된 것은 then 메소드로 받지 않고 catch로 받을 수 있다.

  </script>

</body>
</html>